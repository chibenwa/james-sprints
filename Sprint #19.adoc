= Sprint #19 Product Backlog Refinement

== Attachment (Read)

* NOTE: Document ACL is not supported
** Write a failing acceptance test here
** Update spec with some warnings
* NOTE: Document nested messages are not supported
** Write a failing acceptance test here
** Update spec with some warnings
* TASK: Support inline attachment

== Attachment (Write)

* TASK: upload API
* TASK: update SetMessage to support attachment with blobId
** construct a multipart message with mime4j (lib is already used)
* TASK: use a simple Cassandra TTL to handle upload expiration
** remove TTL once file is referenced
** use Attachment table to store data
** load the whole file in memory for a start
* TASK: handle a max size for upload

== Search

* TASK: deserialize Filter tree into a POJO tree
* TASK: map the Filter POJO tree to a SearchQuery
** NOTE: no Thread* support
* TASK: make hasAttachment searchable via mailbox-api
* TASK: make GetMessagesList call the search api

Remark. If you want to call here the search API for Messages you will have to problems :
 - It returns a list of UID. You may need to add information about mailboxes depending on your implementations choices
 - As such the returned document is not present (reduce network load) + the index document is not the original mail (text extraction). So you will still need a read to Cassandra after your read to ElasticSearch..

== Questions

* Do we want to manage quota on upload ? Ask that with INBOX and UX team

From the spec : 

....
If uploading a file would take the user over quota, the server SHOULD delete previously uploaded (but unused) files before their expiry time. 
....

I guess so.

Beware thow. IMAP quota do not have any concept like "user". It uses QuotaRoots. Mailboxes is attached to a QuotaRoot. The current implementation matches the notion of user, but you have no warranty quotaRoot definition will match the notion of user mailboxes.

* How hard would it be to filter on mailbox and/or users when use Filter on GetMessagesList

Several cases :

 - No filters means all messages the user can see. Then we need a user fileds added while indexing. Note that supporting shared mailboxes here will be hard....
 - Write consideration. We should ensure a user have the right to search a given mailbox. Note that current implementation do not check this.... If you use it directly with JMAP, where user can specify __any__ mailboxId in its request, this becomes a vulnerability.

* How hard is it the handle mailbox rename for search ?

Yes it is. All depends how you represent mailboxes. With the **SimpleMessageSearchIndex**, as it is built on top of MessageMapper fetching, you do not need anything.

With ElasticSearch, it is more complicated as you need to reindex it, at least partially (mailbox field), or even completly with *parent-child* relationShpip.

From ElasticSearch update API :

....
Note, this operation still means full reindex of the document, it just removes some network roundtrips and reduces chances of version conflicts between the get and the index. The _source field needs to be enabled for this feature to work.
....

You will need either way something that looks like **ReIndexerImpl**. Note : you can adapt it to elasticSearch and directly make the update query.

* Does Lucene project work for InMemory tests on Search ?

In memory implementation search do not relly on Lucene at all. It is done threw fetching mailbox messages, and filtering them according to the search query. Every possible search query is supported. Have a look to **SimpleMessageSearchIndex**
